
"use strict";

// 25 lesson - Рекурсия и стек вызовов

/* 
Итеративный способ вычисления степени числа - классический подход с циклом
function pow(x, n) {
    let result = 1; // Начальное значение результата

    // Умножаем x на себя n раз
    for (let i = 0; i < n; i++) {
        result *= x; // result = result * x
    }

    return result; // Возвращаем финальный результат
} */

/**
 * Рекурсивная функция для вычисления степени числа
 * Рекурсия - это когда функция вызывает сама себя с измененными параметрами
 * @param {number} x - основание степени
 * @param {number} n - показатель степени
 * @returns {number} - результат возведения x в степень n
 */
function pow(x, n) {
    // Базовый случай (условие остановки рекурсии) - самый важный элемент рекурсии
    if (n === 1) {
        // Когда степень равна 1, просто возвращаем само число
        // Это предотвращает бесконечный вызов функции
        return x; // Завершаем рекурсию
    } else {
        // Рекурсивный случай - функция вызывает сама себя с уменьшенным параметром
        // x^n = x * x^(n-1) - математическое правило, которое мы используем
        return x * pow(x, n - 1); // Разбиваем задачу на более простую подзадачу
        
        // Пример работы для pow(2, 3):
        // pow(2, 3) = 2 * pow(2, 2)
        // pow(2, 2) = 2 * pow(2, 1) 
        // pow(2, 1) = 2 (базовый случай)
        // Результат: 2 * (2 * 2) = 8
    }
}

// Тестируем функцию - вычисляем 2 в степени 3
console.log(pow(2, 3)); // Выведет: 8

// Демонстрация стека вызовов - каждый вызов добавляется в стек памяти
pow(2, 2); // Вызов 1: 2^2 = 4
pow(2, 3); // Вызов 2: 2^3 = 8  
pow(2, 4); // Вызов 3: 2^4 = 16

// Сложная структура данных с вложенностью для демонстрации рекурсии
// Объект содержит информацию о студентах разных курсов
let students = {
    // Простой массив студентов курса JavaScript
    js: [
        { name: "John", progress: 100 }, // Студент с прогрессом 100%
        { name: "Jane", progress: 90 },  // Студент с прогрессом 90%
        { name: "Jim", progress: 80 },   // Студент с прогрессом 80%
    ],
    // Вложенный объект с курсами HTML (двухуровневая структура)
    html: {
        // Базовый уровень HTML
        basic: [
            { name: "Peter", progress: 70 }, // Студент базового уровня
            { name: "Paul", progress: 60 },  // Студент базового уровня
        ],
        // Продвинутый уровень HTML  
        advanced: [
            { name: "Alice", progress: 85 }, // Студент продвинутого уровня
            { name: "Bob", progress: 95 },   // Студент продвинутого уровня
        ],
    },
};

/**
 * Итеративный подход для подсчета среднего прогресса всех студентов
 * Использует циклы for для обхода всех уровней вложенности структуры данных
 * @param {Object} data - объект с данными о студентах
 * @returns {number} - средний прогресс всех студентов в процентах
 */
function getTotalProgressByIteration(data) {
    let total = 0;    // Накопитель для суммы всех прогрессов
    let students = 0; // Счетчик общего количества студентов

    // Проходим по всем курсам (js, html) в объекте data
    // Object.values(data) возвращает массив значений объекта [js_array, html_object]
    for (let course of Object.values(data)) {
        
        // Проверяем, является ли текущий курс массивом (как js)
        if (Array.isArray(course)) {
            // Если это массив студентов, добавляем их количество к общему счетчику
            students += course.length;
            
            // Перебираем всех студентов в массиве и суммируем их прогресс
            for (let i = 0; i < course.length; i++) {
                total += course[i].progress; // Добавляем прогресс каждого студента
            }
        } else {
            // Если это объект (как html с подкурсами basic/advanced)
            // Проходим по всем подкурсам внутри объекта
            for (let subCourse of Object.values(course)) {
                // Добавляем количество студентов подкурса к общему счетчику
                students += subCourse.length;
                
                // Перебираем всех студентов подкурса и суммируем их прогресс
                for (let i = 0; i < subCourse.length; i++) {
                    total += subCourse[i].progress; // Добавляем прогресс каждого студента
                }
            }
        }
    }

    // Возвращаем средний прогресс: общая сумма прогресса / количество студентов
    return total / students;
}

// Вызываем функцию и выводим результат в консоль
console.log(getTotalProgressByIteration(students)); // Выведет средний прогресс всех студентов

/**
 * Рекурсивный подход для подсчета среднего прогресса всех студентов
 * Функция вызывает сама себя для обработки вложенных структур данных
 * Более элегантное решение для работы со сложными вложенными структурами
 * @param {Object|Array} data - объект или массив с данными о студентах
 * @returns {Array} - массив [общий_прогресс, количество_студентов]
 */
function getTotalProgressByRecursion(data) {
    // Базовый случай: если получили массив студентов (конечная точка рекурсии)
    if (Array.isArray(data)) {
        let total = 0; // Накопитель для суммы прогресса студентов в массиве

        // Перебираем всех студентов в массиве и суммируем их прогресс
        for (let i = 0; i < data.length; i++) {
            total += data[i].progress; // Добавляем прогресс каждого студента
        }

        // Возвращаем массив: [сумма_прогресса, количество_студентов]
        return [total, data.length];
    } else {
        // Рекурсивный случай: если получили объект с вложенными структурами
        let total = [0, 0]; // [сумма_прогресса, количество_студентов]

        // Проходим по всем значениям объекта (курсы, подкурсы)
        // Object.values(data) извлекает все значения из объекта
        for (let subData of Object.values(data)) {
            // РЕКУРСИВНЫЙ ВЫЗОВ: функция вызывает сама себя для обработки подструктуры
            const subDataArr = getTotalProgressByRecursion(subData);
            
            // Накапливаем результаты: добавляем прогресс и количество студентов
            total[0] += subDataArr[0]; // Добавляем сумму прогресса из подструктуры
            total[1] += subDataArr[1]; // Добавляем количество студентов из подструктуры
        }

        // Возвращаем накопленные результаты для текущего уровня
        return total;
    }
}

// Получаем результат в виде массива [общий_прогресс, количество_студентов]
const result = getTotalProgressByRecursion(students);

// Вычисляем и выводим средний прогресс: общий_прогресс / количество_студентов
console.log(result[0] / result[1]); // Выведет тот же результат, что и итеративная функция

/* 
Пошаговое объяснение работы рекурсии:

1. Первый вызов: getTotalProgressByRecursion(students)
   - students - объект, не массив
   - Идем в блок else
   - Object.values(students) = [js_array, html_object]

2. Для js_array:
   - getTotalProgressByRecursion(js_array)
   - js_array - массив, идем в if (базовый случай)
   - Считаем сумму: 100+90+80 = 270, количество: 3
   - Возвращаем [270, 3]

3. Для html_object:
   - getTotalProgressByRecursion(html_object)  
   - html_object - объект, идем в else (рекурсивный случай)
   - Object.values(html_object) = [basic_array, advanced_array]
   
   3.1. Для basic_array:
        - getTotalProgressByRecursion(basic_array)
        - basic_array - массив, идем в if (базовый случай)
        - Считаем: 70+60 = 130, количество: 2
        - Возвращаем [130, 2]
   
   3.2. Для advanced_array:
        - getTotalProgressByRecursion(advanced_array)
        - advanced_array - массив, идем в if (базовый случай)
        - Считаем: 85+95 = 180, количество: 2
        - Возвращаем [180, 2]
   
   Объединяем результаты html: [130+180, 2+2] = [310, 4]

4. Итоговый результат: [270+310, 3+4] = [580, 7]
5. Средний прогресс: 580/7 ≈ 82.86%

Преимущества рекурсии:
- Код более читаемый и понятный
- Легко масштабируется на любую глубину вложенности
- Автоматически обрабатывает структуры разной сложности
- Не нужно заранее знать количество уровней вложенности
*/